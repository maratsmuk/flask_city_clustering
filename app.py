# -*- coding: utf-8 -*-
"""city_clustering_for_flask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1je28Niym1B57O3dMJdvn1_BjYyi3UwxA
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
#!pip install geocoder
#!pip install folium
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
import json # library to handle JSON files

from geopy.geocoders import Nominatim # convert an address into latitude and longitude values

import requests # library to handle requests
from pandas.io.json import json_normalize # tranform JSON file into a pandas dataframe

# Matplotlib and associated plotting modules
import matplotlib.cm as cm
import matplotlib.colors as colors
import matplotlib.pyplot as plt
# %matplotlib inline  
import seaborn as sns
# import k-means from clustering stage
from sklearn.cluster import KMeans
import folium # map rendering library
import geocoder # import geocoder
import os
import re
import operator
import nltk
import pickle
from nltk.tokenize import word_tokenize
from nltk import pos_tag
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from collections import defaultdict
from nltk.corpus import wordnet as wn
from sklearn.feature_extraction.text import TfidfVectorizer
import flask
import pickle
import json
#!pip install transliterate
#from transliterate import translit, get_available_language_codes
print('Libraries imported.')
app = flask.Flask(__name__)
def get_locations(city,city_en):
  df_data_1 = pd.read_csv('RU.txt',header = None, sep = '\t')
  df_data_1.columns = ['country code', 'postal code', 'place name', 'admin name1','admin code1','admin name2','admin code2','admin name3','admin code3','latitude','longitude','accuracy']
  df_data_1.head()
  df_data_1 = df_data_1[df_data_1['place name'].str.find(city)==0]
  pcodes = list(df_data_1['postal code'])
  #print(pcodes[0:5])
  df_city= pd.DataFrame()
  geolocator = Nominatim(user_agent="city_explorer")
  locations = []
  for pcode in pcodes:
    address = str(pcode)+', '+city_en+', Russia'
    try:
      location = geolocator.geocode(address)
      if [location.latitude,location.longitude] not in locations:
        locations.append([location.latitude,location.longitude])
        df_city = df_city.append(pd.DataFrame([[str(pcode),location.latitude,location.longitude]]))
    except:
      print('error in '+address+', coordinates have not been changed')
  df_city.columns = ['Postal Code', 'Latitude', 'Longitude']
  df_city.set_index('Postal Code',inplace=True)
  return df_city
def get_main_categories(CLIENT_ID,CLIENT_SECRET,VERSION):
  url = 'https://api.foursquare.com/v2/venues/categories?&client_id={}&client_secret={}&v={}'.format(
              CLIENT_ID, 
              CLIENT_SECRET, 
              VERSION)
  results = requests.get(url).json()['response']['categories']
  n_cat = len(results)
  main_categories = pd.DataFrame(columns = ['name','id'])
  main_categories_dict = {}
  for categ in range(n_cat):
      cat_id = results[categ]['id']
      main_categories.at[categ] = [results[categ]['name'], cat_id]
      main_categories_dict[cat_id] = []
      stack_subcat = []
      subcat = results[categ]['categories']
      main_categories_dict[cat_id].append(results[categ]['name']) 
      if subcat:
          for i in range(len(subcat)):
              stack_subcat.append(subcat[i])
      while stack_subcat:
          subcat = stack_subcat.pop()
          main_categories_dict[cat_id].append(subcat['name']) 
          if subcat['categories']:
              for i in range(len(subcat['categories'])):
                  stack_subcat.append(subcat['categories'][i])
      #print(results[categ]['name']+' (id '+results[categ]['id']+'),')
  main_categories.set_index('id',inplace = True)
  return main_categories,main_categories_dict

def getNearbyVenues(names, latitudes, longitudes, CLIENT_ID,CLIENT_SECRET,VERSION,LIMIT, radius=1000):
    
    venues_list=[]
    for name, lat, lng in zip(names, latitudes, longitudes):
        #print(name)
            
        # create the API request URL
        url = 'https://api.foursquare.com/v2/venues/explore?&client_id={}&client_secret={}&v={}&ll={},{}&radius={}&limit={}'.format(
            CLIENT_ID, 
            CLIENT_SECRET, 
            VERSION, 
            lat, 
            lng, 
            radius, 
            LIMIT)
            
        # make the GET request
        results = requests.get(url).json()["response"]['groups'][0]['items']
        
        # return only relevant information for each nearby venue
        venues_list.append([(
            name, 
            lat, 
            lng, 
            v['venue']['name'], 
            v['venue']['location']['lat'], 
            v['venue']['location']['lng'],  
            v['venue']['categories'][0]['name']) for v in results])

    nearby_venues = pd.DataFrame([item for venue_list in venues_list for item in venue_list])
    nearby_venues.columns = ['Neighborhood', 
                  'Neighborhood Latitude', 
                  'Neighborhood Longitude', 
                  'Venue', 
                  'Venue Latitude', 
                  'Venue Longitude', 
                  'Venue Category']
    
    return(nearby_venues)
def cluster_city(nclusters,grouped):
    grouped_clustering = grouped.drop('Neighborhood', 1)
    kmeans = KMeans(n_clusters=nclusters, random_state=1).fit(grouped_clustering)
    clusters_unsorted = []
    clusters_sorted = []
    for i in range(nclusters):
        clusters_unsorted.append(grouped_clustering.loc[kmeans.labels_ == i].mean().mean())
    clusters_sorted = np.sort(clusters_unsorted)[::-1]
    cluster_labels = np.copy(kmeans.labels_)
    for i in range(nclusters):
        cluster_labels[kmeans.labels_==clusters_unsorted.index(clusters_sorted[i])] = i
    kmeans.labels_ = cluster_labels
    return kmeans
def return_most_common_venues(row, num_top_venues):
    row_categories = row.iloc[1:]
    row_categories_sorted = row_categories.sort_values(ascending=False)
    result_common = []
    if len(row_categories_sorted.index.values)<num_top_venues:
        result_common = list(row_categories_sorted.index.values[0:len(row_categories_sorted.index.values)])
        for i in range(len(row_categories_sorted.index.values),num_top_venues):
            result_common.append('none')
    else:
        result_common = row_categories_sorted.index.values[0:num_top_venues]
    return result_common
def create_map_clustered(city, df_city,latitude,longitude, kclusters, radius=1000):
    # create map
    map_clusters = folium.Map(width=500,height=500,location=[latitude, longitude], zoom_start=10)
    # set color scheme for the clusters
    x = np.arange(kclusters)
    ys = [i + x + (i*x)**2 for i in range(kclusters)]
    colors_array = cm.rainbow(np.linspace(0, 1, len(ys)))
    #rainbow = [colors.rgb2hex(i) for i in colors_array]
    mycolors = ['red','green','blue','magenta','yellow','cyan','black']
    # add markers to the map
    markers_colors = []
    for lat, lon, poi, cluster in zip(df_city['Latitude'], df_city['Longitude'], df_city['Postal Code'], df_city['Cluster Labels']):
        label = folium.Popup(str(poi) + ' Cluster' + str(cluster), parse_html=True)
        folium.CircleMarker(
            [lat, lon],
            radius=5,
            popup=label,
            color=mycolors[cluster],
            fill=True,
            fill_color=mycolors[cluster],
            fill_opacity=0.7).add_to(map_clusters)
    return map_clusters
def prepare_venues(city,city_en,df_city,main_categories,main_categories_dict,CLIENT_ID,CLIENT_SECRET,VERSION,LIMIT):
  myvenues = getNearbyVenues(df_city.index, df_city['Latitude'], df_city['Longitude'],CLIENT_ID,CLIENT_SECRET,VERSION,LIMIT,1000)
  cat_ids = list(main_categories_dict.keys())
  myvenues['Neighborhood']=myvenues['Neighborhood'].astype(str)
  myvenues.rename(columns={'Venue Category': 'Venue Micro Category'},inplace = True)
  for venues_index in myvenues.index: 
      for macro_cat in cat_ids:
          if myvenues.loc[venues_index,'Venue Micro Category'] in main_categories_dict[macro_cat]:
              myvenues.at[venues_index,'Venue Category'] =  main_categories.loc[macro_cat]['name']
              break
  myvenues.drop_duplicates(subset=list(myvenues.columns)[1:], keep='first', inplace=True)
  myvenues.reset_index(inplace = True)
  myvenues.drop('index',axis=1,inplace=True)
  return myvenues
def prepare_dataframes(myvenues):
  onehot = pd.DataFrame()
  onehot = pd.get_dummies(myvenues[['Venue Category']], prefix="", prefix_sep="")
  # add neighborhood column back to dataframe
  onehot['Neighborhood'] = myvenues['Neighborhood'] 
  # move neighborhood column to the first column
  ind_nei = onehot.columns.tolist().index('Neighborhood');
  fixed_columns = [onehot.columns[ind_nei]]+list(onehot.columns[0:ind_nei])+list(onehot.columns[ind_nei+1:])
  onehot = onehot[fixed_columns]
  columns = onehot.groupby('Neighborhood').sum().sum().index[onehot.groupby('Neighborhood').sum().sum()>50].tolist()
  onehot = onehot[['Neighborhood']+columns]
  #print('The shape of the onehot_dict[',city_en,']:', onehot.shape)
  grouped = onehot.groupby('Neighborhood').sum().div(onehot.sum()[1:]).reset_index()
  return onehot,grouped
def main_clustering_procedure(city,city_en,CLIENT_ID,CLIENT_SECRET,VERSION,LIMIT):
  df_city = get_locations(city,city_en)
  #display(df_city.head())
  main_categories,main_categories_dict = get_main_categories(CLIENT_ID,CLIENT_SECRET,VERSION)
  myvenues = prepare_venues(city,city_en,df_city,main_categories,main_categories_dict,CLIENT_ID,CLIENT_SECRET,VERSION,LIMIT)
  onehot,grouped = prepare_dataframes(myvenues)
  kmeans = cluster_city(4,grouped)  
  num_top_venues = 3
  indicators = ['st', 'nd', 'rd']
  columns = ['Neighborhood']
  # create columns according to number of top venues
  for ind in np.arange(num_top_venues):
    try:
      columns.append('{}{} Most Common Venue'.format(ind+1, indicators[ind]))
    except:
      columns.append('{}th Most Common Venue'.format(ind+1))
  venues_sorted = pd.DataFrame(columns=columns)
  venues_sorted['Neighborhood'] = grouped['Neighborhood']
  df_for_common = onehot.groupby('Neighborhood').sum().reset_index()
  for ind in np.arange(grouped.shape[0]):
    venues_sorted.iloc[ind, 1:] = return_most_common_venues(df_for_common.iloc[ind, :], num_top_venues)
  #print(venues_sorted.shape,len(kmeans.labels_))
  venues_sorted.insert(0, 'Cluster Labels', kmeans.labels_)
  #print(venues_sorted_dict[city_en].head())
  merged = df_city
  merged.reset_index(inplace=True)
  # merge cities_merged with df to add latitude/longitude for each neighborhood
  merged = merged.join(venues_sorted.set_index('Neighborhood'), on='Postal Code')
  #print(cities_merged[city])
  merged.drop(merged[merged['Cluster Labels'].isnull()].index,inplace = True)
  merged.reset_index(drop = True, inplace = True)
  merged['Cluster Labels'] = merged['Cluster Labels'].astype(int)
  if 'index' in list(merged.columns):
      merged.drop('index',axis=1,inplace=True)
  return myvenues,merged

#-------- ROUTES GO HERE -----------#
@app.route('/')
def index():
    start_coords = (46.9540700, 142.7360300)
    folium_map = folium.Map(location=start_coords, zoom_start=5)
    return folium_map._repr_html_()
@app.route('/Map', methods=["GET"])
def create_map():
  city = flask.request.args.get('city')
  city_en = flask.request.args.get('city_en')
  
	
  #city = flask.request.form['city']
  #city_en = flask.request.form['city_en']
  #CLIENT_ID = flask.request.form['client_id']
  #CLIENT_SECRET = flask.request.form['client_secret']
  #VERSION = flask.request.form['version']
  #LIMIT = flask.request.form['limit']
  df_city = get_locations(city,city_en)
  # create map
  #df_collection_cities['Нижний Новгород']
  map_city = folium.Map(location=[df_city.Latitude.mean(), df_city.Longitude.mean()], zoom_start=11)
  # add markers to map
  for lat, lng, pcode in zip(df_city['Latitude'], df_city['Longitude'], df_city.index):
      #label = '{}, {}'.format(neighborhood, borough)
      label = str(pcode)
      label = folium.Popup(label, parse_html=True)
      folium.Circle(
          [lat, lng],
          radius=100,
          popup=label,
          color='blue',
          fill=True,
          fill_color='#3186cc',
          fill_opacity=0.7,
          parse_html=False).add_to(map_city)  
  return map_city._repr_html_(),df_city.to_json()
  


